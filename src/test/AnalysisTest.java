import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.visitor.VoidVisitor;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import graph.BlockType;
import graph.GraphEdge;
import graph.GraphNode;
import graph.StateWrapper;
import org.chocosolver.solver.constraints.nary.nvalue.amnv.graph.G;
import org.junit.Test;
import visitor.MethodVisitor;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

import static org.junit.Assert.*;

public class AnalysisTest {

    public List<GraphNode> parseASTToGraph(String filePath) {
        // Configure type solvers
        ReflectionTypeSolver reflectionTypeSolver = new ReflectionTypeSolver();

        // Combine the type solvers
        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
        combinedTypeSolver.add(reflectionTypeSolver);

        // Configure symbol resolver with the combined type solver
        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
        StaticJavaParser.getParserConfiguration().setSymbolResolver(symbolSolver);

        try {
            CompilationUnit cu = StaticJavaParser.parse(Files.newInputStream(Paths.get(filePath)));
            Set<MethodDeclaration> methodDeclarations = new HashSet<>();
            List<TypeDeclaration<?>> types = cu.getTypes();
            for (int i = 0; i < types.size(); i++) {
                List<MethodDeclaration> mds = types.get(i).getMethods();
                methodDeclarations.addAll(mds);
            }
            List<GraphNode> nodes = new ArrayList<>();
            StateWrapper init = new StateWrapper(nodes, new Stack<>());
            VoidVisitor<StateWrapper> methodVisitor = new MethodVisitor(methodDeclarations);
            methodVisitor.visit(cu, init);
            return nodes;

        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    public void compareGraphHelper(GraphNode expected, GraphNode actual) {
        Set<GraphNode> visited = new HashSet<>();
        compareGraphHelper(expected, actual, visited);
    }

    private void compareGraphHelper(GraphNode expected, GraphNode actual, Set<GraphNode> visited) {
        /** Start Code Generated by [ChatGPT] on [April 2, 2024] */
        // Compare node at this level
        compareNodeHelper(expected, actual);

        // Add to set so we don't cycle
        visited.add(expected);
        visited.add(actual);

        // Compare edges at this level
        List<GraphEdge> expectedEdges = expected.edges;
        List<GraphEdge> actualEdges = actual.edges;

        if (expectedEdges.size() != actualEdges.size()) {
            fail(String.format("Expected size of edge list for node %s: %s, Got: %s", expected.toString(), expectedEdges.size(), actualEdges.size()));
        }

        for (int i = 0; i < expectedEdges.size(); i++) {
            compareEdgeHelper(expectedEdges.get(i), actualEdges.get(i));
        }

        // Compare children
        for (int i = 0; i < actualEdges.size(); i++) {
            GraphNode expectedChild = expectedEdges.get(i).getNode();
            GraphNode actualChild = actualEdges.get(i).getNode();

            if (!visited.contains(expectedChild) && !visited.contains(actualChild)) {
                compareGraphHelper(expectedChild, actualChild, visited);
            }
        }
        /** Start Code Generated by [ChatGPT] on [April 2, 2024] */
    }



    public void compareNodeHelper(GraphNode expected, GraphNode actual) {
        assertTrue(String.format("Expected: %s, Got: %s", expected, actual),
                actual.equalTextAndType(expected));
    }

    public void compareEdgeHelper(GraphEdge expected, GraphEdge actual) {
        assertTrue(String.format("Edge connecting to Node %s is WRONG. Expected label: \"%s\", Got: \"%s\"; Expected " +
                                "isDead: " +
                                "%s, Got: %s",
                        expected.getNode().toString(), expected.label, actual.label, expected.isDead, actual.isDead),
                actual.equalLabelAndIsDead(expected));
    }

    @Test
    public void testSimpleForEachLoop() {
        String filePath = "src/test/testClasses/ForEachTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [forEachMethod] {method_decl}
         *  -> [int[] arr = {1,2,3}] {stmt}
         *      -> [int sum = 0] {stmt}
         *         -> [for(int a : arr)] {stmt}
         *             -> [iterator()] {stmt}
         *                 -> [iterator.hasNext()] {conditional}
         *                    -> [sum += a] {stmt}
         *                        -> [System.out.println(a)] {method_call}
         *                            -> [iterator.next()] {method_call}
         *                        -> [System.out.println("after loop")] {method_call}
         *                           -> [if (sum == 0)] {conditional}
         *                              -> [System.out.println("Greater than zero")] {method_call}
     *                                  -> [System.out.println("Unknown")] {method_call}
         **/

        GraphNode forEachMethod = new GraphNode(BlockType.METHOD_DECL, "forEachMethod()");
        GraphNode arrInit = new GraphNode(BlockType.STMT, "int[] arr = { 1, 2, 3 }");
        GraphNode sumInit = new GraphNode(BlockType.STMT, "int sum = 0");
        GraphNode forEach = new GraphNode(BlockType.FOREACH, "for(int a : arr)");
        GraphNode iterator = new GraphNode(BlockType.STMT, "iterator()");
        GraphNode hasNext = new GraphNode(BlockType.IF, "iterator.hasNext()");
        GraphNode sumIncrement = new GraphNode(BlockType.STMT, "sum = sum + a");
        GraphNode forEachPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(a)");
        GraphNode next = new GraphNode(BlockType.STMT, "iterator.next()");
        GraphNode afterLoop  = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"after loop\")");
        GraphNode conditional = new GraphNode(BlockType.IF, "if (sum == 0)");
        GraphNode thenCondition = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Greater than zero\")");
        GraphNode elseCondition = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Unknown\")");

        GraphEdge methodToArrInit = new GraphEdge(arrInit,"", false);
        GraphEdge arrInitToSumInit = new GraphEdge(sumInit,"", false);
        GraphEdge sumInitToLoop = new GraphEdge(forEach, "", false);
        GraphEdge loopToIterator = new GraphEdge(iterator, "", false);
        GraphEdge iteratorToHasNext = new GraphEdge(hasNext, "", false);
        GraphEdge hasNextToSumIncrement = new GraphEdge(sumIncrement, "then", false);
        GraphEdge sumIncrementToPrint = new GraphEdge(forEachPrint, "", false);
        GraphEdge hasNextToAfterLoop = new GraphEdge(afterLoop, "else", false);
        GraphEdge printToNext = new GraphEdge(next, "", false);
        GraphEdge nextToHasNext = new GraphEdge(hasNext, "", false);
        GraphEdge afterLoopToConditional = new GraphEdge(conditional, "", false);
        GraphEdge conditionalToThen = new GraphEdge(thenCondition, "then", false);
        GraphEdge conditionalToElse = new GraphEdge(elseCondition, "else", false);




        forEachMethod.addEdge(methodToArrInit);
        arrInit.addEdge(arrInitToSumInit);
        sumInit.addEdge(sumInitToLoop);
        forEach.addEdge(loopToIterator);
        iterator.addEdge(iteratorToHasNext);
        hasNext.addEdge(hasNextToSumIncrement);
        sumIncrement.addEdge(sumIncrementToPrint);
        hasNext.addEdge(hasNextToAfterLoop);
        forEachPrint.addEdge(printToNext);
        next.addEdge(nextToHasNext);
        afterLoop.addEdge(afterLoopToConditional);
        conditional.addEdge(conditionalToThen);
        conditional.addEdge(conditionalToElse);


        try {
            compareGraphHelper(forEachMethod, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }


    @Test
    public void testSimpleForLoop() {
        String filePath = "src/test/testClasses/ForLoopTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [ForLoopy] {method_decl}
         *      -> [for(int i = 0; i < 8; i++)] {stmt}
         *          -> [i < 8] {conditional}
         *              -> [int x = i] {stmt}
         *                  -> [i++] {stmt}
         *                      -> [BACK TO i < 8]
         *              -> [boolean coolStuff = y < 0 ? true : false] {stmt}
        **/

        GraphNode expectedForLoopy = new GraphNode(BlockType.METHOD_DECL, "ForLoopy(int y)");
        GraphNode expectedForStmt = new GraphNode(BlockType.FOR, "for(int i = 0; i < 8; i++)");
        GraphNode expectedCondStmt = new GraphNode(BlockType.IF, "i < 8");
        GraphNode expectedForBodyStmt = new GraphNode(BlockType.STMT, "int x = i");
        GraphNode expectedUpdateStmt = new GraphNode(BlockType.STMT, "i++");
        GraphNode expectedAfterLoopStmt = new GraphNode(BlockType.STMT, "boolean coolStuff = y < 0 ? true : false");

        try {
            GraphNode actualForLoopy = resNode;
            GraphNode actualForStmt = actualForLoopy.getChild(0);
            GraphNode actualCondStmt = actualForStmt.getChild(0);
            GraphNode actualForBodyStmt = actualCondStmt.getChild(0);
            GraphNode actualUpdateStmt = actualForBodyStmt.getChild(0);
            GraphNode actualAfterLoopStmt = actualCondStmt.getChild(1);


            // Use this instead of plain assertEquals to avoid cycle StackOverflowError.
            compareNodeHelper(expectedForLoopy, actualForLoopy);
            compareNodeHelper(expectedForStmt, actualForStmt);
            compareNodeHelper(expectedCondStmt, actualCondStmt);
            compareNodeHelper(expectedForBodyStmt, actualForBodyStmt);
            compareNodeHelper(expectedUpdateStmt, actualUpdateStmt);
            compareNodeHelper(expectedAfterLoopStmt, actualAfterLoopStmt);

        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testSimpleWhileLoop() {
        String filePath = "src/test/testClasses/WhileLoopTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [WhileLoopy] {method_decl}
         *      -> [int oddNumber = 1] {stmt}
         *          -> [while (oddNumber % 2 != 0)] {while}
         *              -> [oddNumber % 2 != 0)] {conditional}
         *                  -> [oddNumber += 1] {stmt}
         *                      -> [BACK TO COND]
         *                  -> [int noLongerOdd = oddNumber] {stmt}
         **/

        GraphNode eWhileLoopy = new GraphNode(BlockType.METHOD_DECL, "WhileLoopy(boolean wheely)");
        GraphNode eOddNumAssign = new GraphNode(BlockType.STMT, "int oddNumber = 1");
        GraphNode eWhileStmt = new GraphNode(BlockType.WHILE, "while(oddNumber % 2 != 0)");
        GraphNode eCondStmt = new GraphNode(BlockType.IF, "oddNumber % 2 != 0");
        GraphNode eWhileBodyLine1 = new GraphNode(BlockType.STMT, "oddNumber += 1");
        GraphNode eAfterWhile = new GraphNode(BlockType.STMT, "int noLongerOdd = oddNumber");

        try {
            GraphNode aWhileLoopy = resNode;
            GraphNode aOddNumAssign = aWhileLoopy.getChild(0);
            GraphNode aWhileStmt = aOddNumAssign.getChild(0);
            GraphNode aCondStmt = aWhileStmt.getChild(0);
            GraphNode aWhileBodyLine1 = aCondStmt.getChild(0);
            GraphNode aAfterWhile = aCondStmt.getChild(1);


            // Use this instead of plain assertEquals to avoid cycle StackOverflowError.
            compareNodeHelper(eWhileLoopy, aWhileLoopy);
            compareNodeHelper(eOddNumAssign, aOddNumAssign);
            compareNodeHelper(eWhileStmt, aWhileStmt);
            compareNodeHelper(eCondStmt, aCondStmt);
            compareNodeHelper(eWhileBodyLine1, aWhileBodyLine1);
            compareNodeHelper(eAfterWhile, aAfterWhile);

        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testMethodCallWithArguments() {
        String filePath = "src/test/testClasses/MethodCallWithArguments.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode fooNode = res.get(0);

        // TODO: test booNode.
        GraphNode booNode = res.get(1);

        /** Expected structure:
         *  [foo] {method_decl}
         *     -> [int x = 0] {stmt}
         *        -> [boo(8, "Scary", false)] {method_call}
         *          -> [if (x > 1)] {conditional} --> LINKS TO *A*
         *              ->[println("X IS GREATER THAN 1!")] {method_call} {notDead} --> LINKS TO *A*
         *
         *          *A*
         *          [if (str.equals("Scary"))]
         *              -> [println("BOOOOO!")] {method_call} {notDead} --> LINK TO *B*
         *                  -> [isScary = true] {stmt}
         *              -> [isScary = false] {stmt} {Dead}  --> LINK TO *B*
         *
         *          *B*
         *          [if (!isScary)] {method_call}
         *              ->[println("DONT RUN AWAY")] {
         *
         *  [boo] {method_decl}
         */

        /** Start Code Generated by [ChatGPT] on [April 4, 2024] */
        // Creating GraphNodes for each block or statement
        GraphNode foo = new GraphNode(BlockType.METHOD_DECL, "foo()");
        GraphNode xAssignment = new GraphNode(BlockType.STMT, "int x = 0");

        GraphNode booCall = new GraphNode(BlockType.METHOD_CALL, "boo(8, \"Scary\", false)");

        GraphNode firstIf = new GraphNode(BlockType.IF, "if (x > 1)");
        GraphNode firstIfPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"X IS GREATER THAN 1!\")");

        GraphNode stringIf = new GraphNode(BlockType.IF, "if (str.equals(\"Scary\"))");
        GraphNode stringIfPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"BOOOOO!\")");
        GraphNode isScaryTrue = new GraphNode(BlockType.STMT, "isScary = true");
        GraphNode isScaryFalse = new GraphNode(BlockType.STMT, "isScary = false");

        GraphNode scaryIf = new GraphNode(BlockType.IF, "if (!isScary)");
        GraphNode dontrunPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"DONT RUN AWAY\")");

        // Linking GraphNodes with edges
        foo.addEdge(new GraphEdge(xAssignment, "", false));
        xAssignment.addEdge(new GraphEdge(booCall, "", false));

        booCall.addEdge(new GraphEdge(firstIf, "", false));

        // if (x > 8) <--- true.
        firstIf.addEdge(new GraphEdge(firstIfPrint, "then", false));
        firstIfPrint.addEdge(new GraphEdge(stringIf, "", false));
        firstIf.addEdge(new GraphEdge(stringIf, "else", false));

        // if (str.equals("Scary")) <--- true.
        stringIf.addEdge(new GraphEdge(stringIfPrint, "then", false));
        stringIfPrint.addEdge(new GraphEdge(isScaryTrue, "", false));
        isScaryTrue.addEdge(new GraphEdge(scaryIf, "", false));
        
        stringIf.addEdge(new GraphEdge(isScaryFalse, "else", true)); // Else is dead.
        isScaryFalse.addEdge(new GraphEdge(scaryIf, "", true));

        // if (!isScary) <-- true
        scaryIf.addEdge(new GraphEdge(dontrunPrint, "then", true));

        /** End Code Generated by [ChatGPT] on [April 2, 2024] */

        try {
            compareGraphHelper(foo, fooNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testSimpleContinue() {
        String filePath =  "src/test/testClasses/ContinueTest.txt";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure
         * [loops] {method_decl}
         *    -> [for (int i = 0; i < 8; i++)] {for}
         *      -> [i < 8] {conditional} *A*
         *        -> [for (int j = 0; j < 8; j++)] {for} {then}
         *          -> [j < 8] {conditional} *B*
         *              -> [println("ALIVE!")] {method_call} {then}
         *                  -> continue {stmt} --> LINKS to *C*
         *                      -> [println("DEAD!")
         *                          -> [j++] {stmt} *C* --> LINKS BACK TO *B*
         *              -> [println("ALIVE2")] {method_call} {else}
         *                  -> [i++] {stmt} --> LINKS BACK TO *A*
         */

        /** Start Code Generated by [ChatGPT] on [April 5, 2024] */
        GraphNode loops = new GraphNode(BlockType.METHOD_DECL, "loops()");
        GraphNode outerFor = new GraphNode(BlockType.FOR, "for(int i = 0; i < 8; i++)");
        GraphNode outerConditional = new GraphNode(BlockType.IF, "i < 8");
        GraphNode innerFor = new GraphNode(BlockType.FOR, "for(int j = 0; j < 8; j++)");
        GraphNode innerConditional = new GraphNode(BlockType.IF, "j < 8");
        GraphNode alivePrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"ALIVE!\")");
        GraphNode continueStmt = new GraphNode(BlockType.STMT, "continue");
        GraphNode deadPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"DEAD!\")");
        GraphNode alive2Print = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"ALIVE2!\")");
        GraphNode jIncrement = new GraphNode(BlockType.STMT, "j++");
        GraphNode iIncrement = new GraphNode(BlockType.STMT, "i++");

        // Adding edges
        loops.addEdge(new GraphEdge(outerFor, "", false));
        outerFor.addEdge(new GraphEdge(outerConditional, "", false));
        outerConditional.addEdge(new GraphEdge(innerFor, "then", false));
        innerFor.addEdge(new GraphEdge(innerConditional, "", false));
        innerConditional.addEdge(new GraphEdge(alivePrint, "then", false));
        alivePrint.addEdge(new GraphEdge(continueStmt, "", false));

        continueStmt.addEdge(new GraphEdge(jIncrement, "continue", false));
        continueStmt.addEdge(new GraphEdge(deadPrint, "", true));

        deadPrint.addEdge(new GraphEdge(jIncrement, "", false)); // Increment is never dead.
        jIncrement.addEdge(new GraphEdge(innerConditional, "", false)); // Links back to *B*

        innerConditional.addEdge(new GraphEdge(alive2Print, "else", false));
        alive2Print.addEdge(new GraphEdge(iIncrement, "", false));
        iIncrement.addEdge(new GraphEdge(outerConditional, "", false)); // Links back to *A*
        /** End Code Generated by [ChatGPT] on [April 5, 2024] */

        try {
            compareGraphHelper(loops, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testGeneralContinue() {
        String filePath = "src/test/testClasses/ContinueWrappedTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [SimpleContinueUseCase] {method_decl}
         *    -> [int i = 0] {stmt}
         *      -> [while (i < 8)] {while}
         *         -> [i < 8] {conditional} *A* --> LINKS TO *C*
         *           -> [if (true)] {conditional} --> LINKS TO *B*
         *              -> [if (i == -1)] {conditional} {false}
         *                  -> [println("DEAD1")] {method_call} {dead} {then} --> LINKS to *B*
         *                  -> [continue] {stmt} {alive} {else} --> --> LINKS to *A* and *B*
         *
         *               [println("DEAD2")] {method_call} {dead} *B* --> LINKS to *A*
         *      [println("ALIVE")] {method_call} *C*
         */

        /** Start Code Generated by [ChatGPT] on [April 6, 2024] */
        // Create GraphNodes for each block or statement
        GraphNode simpleContinueUseCase = new GraphNode(BlockType.METHOD_DECL, "SimpleContinueUseCase()");
        GraphNode iAssignment = new GraphNode(BlockType.STMT, "int i = 0");
        GraphNode whileLoop = new GraphNode(BlockType.WHILE, "while(i < 8)");
        GraphNode whileConditional = new GraphNode(BlockType.IF, "i < 8");
        GraphNode ifConditional = new GraphNode(BlockType.IF, "if (true)");
        GraphNode ifInnerConditional = new GraphNode(BlockType.IF, "if (i == -1)");
        GraphNode deadPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"DEAD1\")");
        GraphNode continueStmt = new GraphNode(BlockType.STMT, "continue");
        GraphNode dead2Print = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"DEAD2\")");
        GraphNode alivePrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"ALIVE\")");

        // Adding edges
        simpleContinueUseCase.addEdge(new GraphEdge(iAssignment, "", false));
        iAssignment.addEdge(new GraphEdge(whileLoop, "", false));
        whileLoop.addEdge(new GraphEdge(whileConditional, "", false));
        whileConditional.addEdge(new GraphEdge(ifConditional, "then", false));
        whileConditional.addEdge(new GraphEdge(alivePrint, "else", false));

        ifConditional.addEdge(new GraphEdge(ifInnerConditional, "then", false));
        ifConditional.addEdge(new GraphEdge(dead2Print, "else", true));

        ifInnerConditional.addEdge(new GraphEdge(deadPrint, "then", true));
        ifInnerConditional.addEdge(new GraphEdge(continueStmt, "else", false));

        deadPrint.addEdge(new GraphEdge(dead2Print, "", true));
        continueStmt.addEdge(new GraphEdge(whileConditional, "continue", false));
        continueStmt.addEdge(new GraphEdge(dead2Print, "", true));

        // TODO: check whether this edge should be alive/dead
        dead2Print.addEdge(new GraphEdge(whileConditional, "", false));

        /** End Code Generated by [ChatGPT] on [April 4, 2024] */

        try {
            compareGraphHelper(simpleContinueUseCase, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testComplexContinue() {
        String filePath =  "src/test/testClasses/ContinueComplexTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected Structure:
         *  [NestedLoops] {method_decl}
         *    -> [while(true)] {while}
         *      -> [true] {conditional} *C*
         *         -> [for(int i = 0; i < -9; i++)] {for}
         *            -> [i < -9] {conditional} *A*
         *               -> [if (true)] {conditional} {then *A*}
         *                 -> [continue] {stmt} {then} --> --> LINKS to *D* & [println("DEAD1")]
         *                 -> [println("DEAD1")] {method_call} {else} {dead} --> LINKS to *D*
         *                   -> [i++] {stmt} *D* --> LINKS to *A*
         *               -> [println("ALIVE1")] {method_call} {else *A*}
         *                  -> [if (false)] {conditional} --> LINKS TO *B*
         *                     -> [continue] {stmt} {else} --> --> LINKS TO *B* and *C*
         *
         *              [println("DEAD2")] {dead} *B* --> LINKS TO *C*
         */

        /** Start Code Generated by [ChatGPT] on [April 6, 2024] */
        // Create GraphNodes for each block or statement
        GraphNode nestedLoops = new GraphNode(BlockType.METHOD_DECL, "NestedLoops()");
        GraphNode outerWhile = new GraphNode(BlockType.WHILE, "while(true)");
        GraphNode outerConditional = new GraphNode(BlockType.IF, "true");
        GraphNode outerFor = new GraphNode(BlockType.FOR, "for(int i = 0; i < -9; i++)");
        GraphNode outerForConditional = new GraphNode(BlockType.IF, "i < -9");
        GraphNode outerForIncrement = new GraphNode(BlockType.STMT, "i++");
        GraphNode innerIf = new GraphNode(BlockType.IF, "if (true)");
        GraphNode continueStmtA = new GraphNode(BlockType.STMT, "continue");
        GraphNode dead1Print = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"DEAD1\")");
        GraphNode alive1Print = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"ALIVE1\")");
        GraphNode innerIfElse = new GraphNode(BlockType.IF, "if (false)");
        GraphNode continueStmtB = new GraphNode(BlockType.STMT, "continue");
        GraphNode dead2Print = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"DEAD2\")");

        // Adding edges
        nestedLoops.addEdge(new GraphEdge(outerWhile, "", false));
        outerWhile.addEdge(new GraphEdge(outerConditional, "", false));
        outerConditional.addEdge(new GraphEdge(outerFor, "then", false));
        outerFor.addEdge(new GraphEdge(outerForConditional, "", false));

        outerForConditional.addEdge(new GraphEdge(innerIf, "then", false));
        outerForConditional.addEdge(new GraphEdge(alive1Print, "else", false));

        innerIf.addEdge(new GraphEdge(continueStmtA, "then", false));
        innerIf.addEdge(new GraphEdge(dead1Print, "else", true));

        continueStmtA.addEdge(new GraphEdge(outerForIncrement, "continue", false));
        continueStmtA.addEdge(new GraphEdge(dead1Print, "", true));

        // TODO: determine if path to cond isDead =  T/F. Current behaviour is F.
        dead1Print.addEdge(new GraphEdge(outerForIncrement, "", false));

        outerForIncrement.addEdge(new GraphEdge(outerForConditional, "", false));

        alive1Print.addEdge(new GraphEdge(innerIfElse, "", false));

        innerIfElse.addEdge(new GraphEdge(continueStmtB, "else", false));
        innerIfElse.addEdge(new GraphEdge(dead2Print, "then", true));

        continueStmtB.addEdge(new GraphEdge(outerConditional, "continue", false));
        continueStmtB.addEdge(new GraphEdge(dead2Print, "", true));

        // TODO: determine if path to cond isDead =  T/F. Current behaviour is F.
        dead2Print.addEdge(new GraphEdge(outerConditional, "", false));

        /** Start Code Generated by [ChatGPT] on [April 6, 2024] */

        try {
            compareGraphHelper(nestedLoops, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testNestedParametrizedIf() {
        String filePath = "src/test/testClasses/NestedParametrizedIfTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [nestedIfStatement] {method_decl}
         *   -> [if(i > 5)] {conditional}
         *       -> [println("greater than 5")] {method_call}
         *           -> [if(i > 10)] {conditional}
         *               -> [println("also greater than 10")] {method_call}
         *           -> [max(5, 5)] {method_call}
         *       -> [println("less than or equal to 5")] {method_call}
         *   -> [println("after both prints")] {method_call}
         **/

        GraphNode expectedNestedIf = new GraphNode(BlockType.METHOD_DECL, "nestedIfStatement(int i)");
        GraphNode expectedOuterIf = new GraphNode(BlockType.IF, "if (i > 5)");
        GraphNode expectedOuterIfPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"greater than 5\")");
        GraphNode expectedInnerIf = new GraphNode(BlockType.IF, "if (i > 10)");
        GraphNode expectedInnerIfPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"also greater than 10\")");
        GraphNode expectedMax = new GraphNode(BlockType.METHOD_CALL, "Math.max(5, 5)");
        GraphNode expectedOuterElsePrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"less than or equal to 5\")");
        GraphNode expectedAfterConditionals = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"after both prints\")");

        GraphEdge methodDeclToOuterIf = new GraphEdge(expectedOuterIf, "", false);
        expectedNestedIf.addEdge(methodDeclToOuterIf);

        GraphEdge outerIfToOuterIfPrint = new GraphEdge(expectedOuterIfPrint, "then", false);
        GraphEdge outerIfToOuterElsePrint = new GraphEdge(expectedOuterElsePrint, "else", false);
        expectedOuterIf.addEdge(outerIfToOuterIfPrint);
        expectedOuterIf.addEdge(outerIfToOuterElsePrint);

        GraphEdge outerIfPrintToInnerIf = new GraphEdge(expectedInnerIf, "", false);
        expectedOuterIfPrint.addEdge(outerIfPrintToInnerIf);

        GraphEdge innerIfToInnerIfPrint = new GraphEdge(expectedInnerIfPrint, "then", false);
        GraphEdge innerIfToMax = new GraphEdge(expectedMax, "else", false);
        expectedInnerIf.addEdge(innerIfToInnerIfPrint);
        expectedInnerIf.addEdge(innerIfToMax);

        GraphEdge innerIfPrintToMax = new GraphEdge(expectedMax, "", false);
        expectedInnerIfPrint.addEdge(innerIfPrintToMax);

        GraphEdge expectedMaxToAfterConditional = new GraphEdge(expectedAfterConditionals, "", false);
        GraphEdge outerElsePrintToAfterConditional = new GraphEdge(expectedAfterConditionals, "", false);
        expectedMax.addEdge(expectedMaxToAfterConditional);
        expectedOuterElsePrint.addEdge(outerElsePrintToAfterConditional);

        try {
            compareGraphHelper(expectedNestedIf, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testStaticallyDeterminableIf() {
        String filePath = "src/test/testClasses/StaticallyDeterminableIfTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [basicIfStatement] {method_decl}
         *  -> [int a = 3] {stmt}
         *      -> [int b = a + 3] {stmt}
         *          -> [if (b > a)] {conditional}
         *              -> [println("b is greater than a")] {method_call}
         *                  -> [String c = "throwaway"] {stmt}
         *                      -> [int d = 5] {stmt}
         *                          -> [int e = -1] {stmt}
         *              -> [println("b is not greater than a")] {method_call}
         *                  -> [int d = 5] {stmt}
         *                      -> [int e = 1] {stmt}
         *      -> [println("afterwards")] {stmt}
         **/

        GraphNode expectedBasicIf = new GraphNode(BlockType.METHOD_DECL, "basicIfStatement()");
        GraphNode expectedA = new GraphNode(BlockType.STMT, "int a = 3");
        GraphNode expectedB = new GraphNode(BlockType.STMT, "int b = a + 3");
        GraphNode expectedIf = new GraphNode(BlockType.IF, "if (b > a)");
        GraphNode expectedIfPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"b is greater than a\")");
        GraphNode expectedIfC = new GraphNode(BlockType.STMT, "String c = \"throwaway\"");
        GraphNode expectedIfD = new GraphNode(BlockType.STMT, "int d = 5");
        GraphNode expectedIfE = new GraphNode(BlockType.STMT, "int e = -1");
        GraphNode expectedElsePrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"b is not greater than a\")");
        GraphNode expectedElseD = new GraphNode(BlockType.STMT, "int d = 5");
        GraphNode expectedElseE = new GraphNode(BlockType.STMT, "int e = 1");
        GraphNode expectedAfterPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"afterwards\")");

        GraphEdge methodToA = new GraphEdge(expectedA, "", false);
        GraphEdge aToB = new GraphEdge(expectedB, "", false);
        GraphEdge bToIf = new GraphEdge(expectedIf, "", false);

        GraphEdge ifToIfPrint = new GraphEdge(expectedIfPrint, "then", false);
        GraphEdge ifPrintToIfC = new GraphEdge(expectedIfC, "", false);
        GraphEdge ifCtoIfD = new GraphEdge(expectedIfD, "", false);
        GraphEdge idDtoIfE = new GraphEdge(expectedIfE, "", false);

        GraphEdge ifToElsePrint = new GraphEdge(expectedElsePrint, "else", true);
        GraphEdge elsePrintToElseD = new GraphEdge(expectedElseD, "", true);
        GraphEdge elseDToElseE = new GraphEdge(expectedElseE, "", true);

        GraphEdge ifEtoAfterPrint = new GraphEdge(expectedAfterPrint, "", false);
        GraphEdge elseEtoAfterPrint = new GraphEdge(expectedAfterPrint, "", true);

        expectedBasicIf.addEdge(methodToA);
        expectedA.addEdge(aToB);
        expectedB.addEdge(bToIf);

        expectedIf.addEdge(ifToIfPrint);
        expectedIfPrint.addEdge(ifPrintToIfC);
        expectedIfC.addEdge(ifCtoIfD);
        expectedIfD.addEdge(idDtoIfE);

        expectedIf.addEdge(ifToElsePrint);
        expectedElsePrint.addEdge(elsePrintToElseD);
        expectedElseD.addEdge(elseDToElseE);

        expectedIfE.addEdge(ifEtoAfterPrint);
        expectedElseE.addEdge(elseEtoAfterPrint);

        try {
            compareGraphHelper(expectedBasicIf, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testNestedStaticallyDeterminableIf() {
        String filePath = "src/test/testClasses/NestedStaticallyDeterminableIfTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [nestedIfStatements] {method_decl}
         *  -> [if(s.length > 5)] {conditional}
         *      -> [System.out.println("String is greater than 5")] {method_call}
         *          -> [if(3 > 5)] {conditional}
         *              -> [System.out.println("This shouldn't happen")] {method_call}
         *                  -> [if(s.length > 5)] {conditional}
         *                      -> [System.out.println("This statement doesn't matter my parent is dead!")] {method_call}
         *  -> [System.out.println("Outside")]
         **/

        GraphNode nestedIfStatements = new GraphNode(BlockType.METHOD_DECL, "nestedIfStatements(String s)");
        GraphNode outerIf = new GraphNode(BlockType.IF, "if (s.length() > 5)");
        GraphNode outerIfPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"String is greater than 5\")");
        GraphNode innerIf = new GraphNode(BlockType.IF, "if (3 > 5)");
        GraphNode innerIfPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"This shouldn't happen\")");
        GraphNode nestedInnerIf = new GraphNode(BlockType.IF, "if (s.length() > 5)");
        GraphNode nestedInnerIfPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"This statement doesn't matter my parent is dead!\")");
        GraphNode afterConditionalPrint = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Outside\")");

        GraphEdge declToOuterIf = new GraphEdge(outerIf, "" , false);
        GraphEdge outerIfToOuterIfPrint = new GraphEdge(outerIfPrint, "then", false);
        GraphEdge outerIfPrintToInnerIf = new GraphEdge(innerIf, "", false);
        GraphEdge innerIfToInnerIfPrint = new GraphEdge(innerIfPrint, "then", true);
        GraphEdge innerIfPrintToNestedInnerIf = new GraphEdge(nestedInnerIf, "", true);
        GraphEdge nestedInnerIfToNestedInnerIfPrint = new GraphEdge(nestedInnerIfPrint, "then", true);

        GraphEdge outerIfToAfterConditional = new GraphEdge(afterConditionalPrint, "else", false);
        GraphEdge innerIfToAfterConditional = new GraphEdge(afterConditionalPrint, "else", false);
        GraphEdge nestedInnerIfToAfterConditional = new GraphEdge(afterConditionalPrint, "else", true);
        GraphEdge nestedInnerIfPrintToAfterConditional = new GraphEdge(afterConditionalPrint, "", true);

        nestedIfStatements.addEdge(declToOuterIf);

        outerIf.addEdge(outerIfToOuterIfPrint);
        outerIf.addEdge(outerIfToAfterConditional);

        outerIfPrint.addEdge(outerIfPrintToInnerIf);

        innerIf.addEdge(innerIfToInnerIfPrint);
        innerIf.addEdge(innerIfToAfterConditional);
        innerIfPrint.addEdge(innerIfPrintToNestedInnerIf);

        nestedInnerIf.addEdge(nestedInnerIfToNestedInnerIfPrint);
        nestedInnerIf.addEdge(nestedInnerIfToAfterConditional);

        nestedInnerIfPrint.addEdge(nestedInnerIfPrintToAfterConditional);

        try {
            compareGraphHelper(nestedIfStatements, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testStaticallyDeterminableString() {
        String filePath = "src/test/testClasses/StaticallyDeterminableStringTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [stringStatement] {method_decl}
         *  -> [s = "wow"] {stmt}
         *      -> [if (s.length() > 2] {conditional}
         *          -> [System.out.println("Greater than two")] {method_call}
         *          -> [System.out.println("Not greater than two")] {method_call}
         **/

        GraphNode stringStatement = new GraphNode(BlockType.METHOD_DECL, "stringStatement()");
        GraphNode stringInit = new GraphNode(BlockType.STMT, "String s = \"wow\"");
        GraphNode ifBlock = new GraphNode(BlockType.IF, "if (s.length() > 2)");
        GraphNode thenBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Greater than two\")");
        GraphNode elseBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Not greater than two\")");

        GraphEdge methodToStringInit = new GraphEdge(stringInit, "", false);
        GraphEdge stringInitToIf = new GraphEdge(ifBlock, "", false);
        GraphEdge ifToThen = new GraphEdge(thenBlock, "then", false);
        GraphEdge ifToElse = new GraphEdge(elseBlock, "else", true);

        stringStatement.addEdge(methodToStringInit);
        stringInit.addEdge(stringInitToIf);
        ifBlock.addEdge(ifToThen);
        ifBlock.addEdge(ifToElse);

        try {
            compareGraphHelper(stringStatement, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testStaticallyDeterminableArray() {
        String filePath = "src/test/testClasses/StaticallyDeterminableArrayTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNodeCompact = res.get(0);

        /** Expected structure:
         * [arrayStatementCompact] {method_decl}
         *  -> [int[] arr = {1,2,3,4,5}] {stmt}
         *      -> [if (arr.length > 2] {conditional}
         *          -> [System.out.println("Greater than two")] {method_call}
         *          -> [System.out.println("Not greater than two")] {method_call}
         **/

        GraphNode arrayStatement = new GraphNode(BlockType.METHOD_DECL, "arrayStatementCompact()");
        GraphNode arrayInit = new GraphNode(BlockType.STMT, "int[] arr = { 1, 2, 3, 4, 5 }");
        GraphNode ifBlock = new GraphNode(BlockType.IF, "if (arr.length > 2)");
        GraphNode thenBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Greater than two\")");
        GraphNode elseBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Not greater than two\")");

        GraphEdge methodToArrayInit = new GraphEdge(arrayInit, "", false);
        GraphEdge arrayInitToIf = new GraphEdge(ifBlock, "", false);
        GraphEdge ifToThen = new GraphEdge(thenBlock, "then", false);
        GraphEdge ifToElse = new GraphEdge(elseBlock, "else", true);

        arrayStatement.addEdge(methodToArrayInit);
        arrayInit.addEdge(arrayInitToIf);
        ifBlock.addEdge(ifToThen);
        ifBlock.addEdge(ifToElse);

        try {
            compareGraphHelper(arrayStatement, resNodeCompact);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }

        /** Expected structure:
         * [arrayStatementSeparated] {method_decl}
         *  -> [int[] arr = {1,2,3,4,5}] {stmt}
         *      -> [int arrLen = arr.length] {stmt}
         *          -> [if (arrLen > 2] {conditional}
         *              -> [System.out.println("Greater than two")] {method_call}
         *              -> [System.out.println("Not greater than two")] {method_call}
         **/
        GraphNode resNodeSeparated = res.get(1);


        arrayStatement = new GraphNode(BlockType.METHOD_DECL, "arrayStatementSeparated()");
        arrayInit = new GraphNode(BlockType.STMT, "int[] arr = { 1, 2, 3, 4, 5 }");
        GraphNode arrayLength = new GraphNode(BlockType.STMT, "int arrLen = arr.length");
        ifBlock = new GraphNode(BlockType.IF, "if (arrLen > 2)");
        thenBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Greater than two\")");
        elseBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Not greater than two\")");

        methodToArrayInit = new GraphEdge(arrayInit, "", false);
        GraphEdge arrayInitToLength = new GraphEdge(arrayLength, "", false);
        GraphEdge arrayLengthToIf = new GraphEdge(ifBlock, "", false);
        ifToThen = new GraphEdge(thenBlock, "then", false);
        ifToElse = new GraphEdge(elseBlock, "else", true);

        arrayStatement.addEdge(methodToArrayInit);
        arrayInit.addEdge(arrayInitToLength);
        arrayLength.addEdge(arrayLengthToIf);
        ifBlock.addEdge(ifToThen);
        ifBlock.addEdge(ifToElse);

        try {
            compareGraphHelper(arrayStatement, resNodeSeparated);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testParametrizedArray() {
        String filePath = "src/test/testClasses/ParametrizedArrayTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [parametrizedArrayMethod] {method_decl}
         *   -> [if (arr.length > 2] {conditional}
         *       -> [System.out.println("Greater than two")] {method_call}
         *       -> [System.out.println("Not greater than two")] {method_call}
         *       -> [System.out.println("afterwards")] {method_call}
         **/

        GraphNode arrayStatement = new GraphNode(BlockType.METHOD_DECL, "parametrizedArrayMethod(int[] arr)");
        GraphNode ifBlock = new GraphNode(BlockType.IF, "if (arr.length > 2)");
        GraphNode thenBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Greater than two\")");
        GraphNode elseBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Not greater than two\")");
        GraphNode afterIf = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"afterwards\")");

        GraphEdge methodToIf = new GraphEdge(ifBlock, "", false);
        GraphEdge ifToThen = new GraphEdge(thenBlock, "then", false);
        GraphEdge ifToElse = new GraphEdge(elseBlock, "else", false);
        GraphEdge thenToAfter = new GraphEdge(afterIf, "", false);
        GraphEdge elseToAfter = new GraphEdge(afterIf, "", false);


        arrayStatement.addEdge(methodToIf);
        ifBlock.addEdge(ifToThen);
        ifBlock.addEdge(ifToElse);
        thenBlock.addEdge(thenToAfter);
        elseBlock.addEdge(elseToAfter);

        try {
            compareGraphHelper(arrayStatement, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testParametrizedString() {
        String filePath = "src/test/testClasses/ParametrizedStringTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [parametrizedStringMethod] {method_decl}
         *   -> [if (s.length() > 2] {conditional}
         *       -> [System.out.println("Greater than two")] {method_call}
         *       -> [System.out.println("Not greater than two")] {method_call}
         *       -> [System.out.println("afterwards")] {method_call}
         **/

        GraphNode stringStatement = new GraphNode(BlockType.METHOD_DECL, "parametrizedStringMethod(String s)");
        GraphNode ifBlock = new GraphNode(BlockType.IF, "if (s.length() > 2)");
        GraphNode thenBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Greater than two\")");
        GraphNode elseBlock = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"Not greater than two\")");
        GraphNode afterIf = new GraphNode(BlockType.METHOD_CALL, "System.out.println(\"afterwards\")");

        GraphEdge methodToIf = new GraphEdge(ifBlock, "", false);
        GraphEdge ifToThen = new GraphEdge(thenBlock, "then", false);
        GraphEdge ifToElse = new GraphEdge(elseBlock, "else", false);
        GraphEdge thenToAfter = new GraphEdge(afterIf, "", false);
        GraphEdge elseToAfter = new GraphEdge(afterIf, "", false);


        stringStatement.addEdge(methodToIf);
        ifBlock.addEdge(ifToThen);
        ifBlock.addEdge(ifToElse);
        thenBlock.addEdge(thenToAfter);
        elseBlock.addEdge(elseToAfter);

        try {
            compareGraphHelper(stringStatement, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

//    @Test
//    public void testSomething(){
//        // Configure type solvers
//        ReflectionTypeSolver reflectionTypeSolver = new ReflectionTypeSolver();
//        JavaParserTypeSolver javaParserTypeSolver = new JavaParserTypeSolver("src/main/java");
//
//        // Combine the type solvers
//        CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();
//        combinedTypeSolver.add(reflectionTypeSolver);
//        combinedTypeSolver.add(javaParserTypeSolver);
//
//        // Configure symbol resolver with the combined type solver
//        JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);
//        StaticJavaParser.getParserConfiguration().setSymbolResolver(symbolSolver);
//
//        try {
//            CompilationUnit cu = StaticJavaParser.parse(Files.newInputStream(Paths.get("src/main/java/examples/Blah.java")));
//            Set<MethodDeclaration> methodDeclarations = new HashSet<>();
//            List<TypeDeclaration<?>> types = cu.getTypes();
//            for (int i = 0; i < types.size(); i++) {
//                List<MethodDeclaration> mds = types.get(i).getMethods();
//                methodDeclarations.addAll(mds);
//            }
//            List<GraphNode> nodes = new ArrayList<>();
//            VoidVisitor<List<GraphNode>> methodVisitor = new MethodVisitor(methodDeclarations);
//            methodVisitor.visit(cu, nodes);
//
//            GraphNode b_method = nodes.get(1);
//
//            // Expected
//            GraphNode expected_b_method = new GraphNode(BlockType.METHOD_DECL, "b_method");
//            GraphNode println = new GraphNode(BlockType.METHOD_CALL, "println");
//            GraphNode toString = new GraphNode(BlockType.METHOD_CALL, "toString");
//            GraphNode tInit = new GraphNode(BlockType.STMT, "Temporary t = new Temporary(\"some arg\")");
//            GraphNode printName = new GraphNode(BlockType.METHOD_CALL, "printName");
//
//            GraphEdge b_method_println = new GraphEdge(println, "", false);
//            expected_b_method.addEdge(b_method_println);
//            GraphEdge println_toString = new GraphEdge(toString, "", false);
//            println.addEdge(println_toString);
//            GraphEdge toString_tIinit = new GraphEdge(tInit, "", false);
//            toString.addEdge(toString_tIinit);
//            GraphEdge tInit_printName = new GraphEdge(printName, "", false);
//            tInit.addEdge(tInit_printName);
//
//            assertEquals(b_method, expected_b_method);
//
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }

    @Test
    public void testSwitch() {
        String filePath = "src/test/testClasses/SwitchTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [SimpleSwitch] {METHOD_DECL}
         *      -> [int i = x] {STMT}
         *          -> [switch (i)] {SWITCH}
         *             -> [i = 1] {STMT}
         *                -> [break] {STMT}
         *             -> [i = 2] {STMT}
         *             -> [i = 3] {STMT}
         *      -> [i = 10]
         **/

        GraphNode eSimpleSwitch = new GraphNode(BlockType.METHOD_DECL, "SimpleSwitch(int x)");
        GraphNode eFirstSTMT = new GraphNode(BlockType.STMT, "int i = x");
        GraphNode eSwitchSTMT = new GraphNode(BlockType.SWITCH, "switch(i)");
        GraphNode eCase1 = new GraphNode(BlockType.STMT, "i = 1");
        GraphNode eBreak = new GraphNode(BlockType.BREAK, "break");
        GraphNode eCase2 = new GraphNode(BlockType.STMT, "i = 2");
        GraphNode eDefault = new GraphNode(BlockType.STMT, "i = 0");
        GraphNode eLastSTMT = new GraphNode(BlockType.STMT, "i = 10");

        try {
            GraphNode aSimpleSwitch = resNode;
            GraphNode aFirstSTMT = aSimpleSwitch.getChild(0);
            GraphNode aSwitchSTMT = aFirstSTMT.getChild(0);
            GraphNode aCase1 = aSwitchSTMT.getChild(0);
            GraphNode aBreak = aCase1.getChild(0);
            GraphNode aCase2 = aSwitchSTMT.getChild(1);
            GraphNode aCase2Fall = aCase2.getChild(0);
            GraphNode aDefault = aSwitchSTMT.getChild(2);
            GraphNode aBreakChild = aBreak.getChild(0);
            GraphNode aDefaultChild = aDefault.getChild(0);


            // Use this instead of plain assertEquals to avoid cycle StackOverflowError.
            compareNodeHelper(eSimpleSwitch, aSimpleSwitch);
            compareNodeHelper(eFirstSTMT, aFirstSTMT);
            compareNodeHelper(eSwitchSTMT, aSwitchSTMT);
            compareNodeHelper(eCase1, aCase1);
            compareNodeHelper(eBreak, aBreak);
            compareNodeHelper(eCase2, aCase2);
            compareNodeHelper(eDefault, aCase2Fall);
            compareNodeHelper(eDefault, aDefault);
            compareNodeHelper(eLastSTMT, aBreakChild);
            compareNodeHelper(eLastSTMT, aDefaultChild);

        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void testMethodInAnotherFile() {
        String filePath = "src/test/testClasses/MethodInAnotherFileTest.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);

        /** Expected structure:
         * [someMethod] {METHOD_DECL}
         *  -> [Temporary t = new Temporary("some arg")] {STMT}
         *      -> [t.printName()] {METHOD_CALL}
         **/

        GraphNode method = new GraphNode(BlockType.METHOD_DECL, "someMethod()");
        GraphNode tInit = new GraphNode(BlockType.STMT, "Temporary t = new Temporary(\"some arg\")");
        GraphNode tPrint = new GraphNode(BlockType.METHOD_CALL, "t.printName()");

        GraphEdge methodToTInit = new GraphEdge(tInit, "", false);
        GraphEdge tInitToTPrint = new GraphEdge(tPrint, "", false);

        method.addEdge(methodToTInit);
        tInit.addEdge(tInitToTPrint);

        try {
            compareGraphHelper(method, resNode);
        } catch (Exception e) {
            fail("Produced incorrect tree." + e.toString());
        }
    }

    @Test
    public void customTest() {
        String filePath =  "src/test/testClasses/Custom.java";
        List<GraphNode> res = parseASTToGraph(filePath);
        GraphNode resNode = res.get(0);
    }
}